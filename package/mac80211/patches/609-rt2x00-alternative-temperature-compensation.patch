Index: compat-wireless-2013-02-22/drivers/net/wireless/rt2x00/rt2800.h
===================================================================
--- compat-wireless-2013-02-22.orig/drivers/net/wireless/rt2x00/rt2800.h	2013-08-09 13:05:59.000000000 +0400
+++ compat-wireless-2013-02-22/drivers/net/wireless/rt2x00/rt2800.h	2013-08-09 13:07:33.000000000 +0400
@@ -2180,6 +2180,111 @@
 #define EEPROM_VERSION_FAE		FIELD16(0x00ff)
 #define EEPROM_VERSION_VERSION		FIELD16(0xff00)
 
+#define EEPROM_TSSI_OVER_OFDM54		0x0037 // The TSSI over OFDM 54Mbps
+#define EEPROM_TSSI_BASE		FIELD16(0x3f00)
+#define EEPROM_CH_2_TSSI_DELTA		FIELD16(0x0f00)
+#define EEPROM_CH_1_TSSI_DELTA		FIELD16(0xf000)
+/*
+ * Per channel tssi deltas
+ */
+
+#define EEPROM_CH_3_4_TSSI_DELTA	0x002a
+#define EEPROM_CH_3_TSSI_DELTA		FIELD16(0x000f)
+#define EEPROM_CH_4_TSSI_DELTA		FIELD16(0x0f00)
+
+#define EEPROM_CH_5_6_TSSI_DELTA	0x002b
+#define EEPROM_CH_5_TSSI_DELTA		FIELD16(0x000f)
+#define EEPROM_CH_6_TSSI_DELTA		FIELD16(0x0f00)
+
+#define EEPROM_CH_7_8_TSSI_DELTA	0x002c
+#define EEPROM_CH_7_TSSI_DELTA		FIELD16(0x000f)
+#define EEPROM_CH_8_TSSI_DELTA		FIELD16(0x0f00)
+
+#define EEPROM_CH_9_10_TSSI_DELTA	0x002d
+#define EEPROM_CH_9_TSSI_DELTA		FIELD16(0x000f)
+#define EEPROM_CH_10_TSSI_DELTA		FIELD16(0x0f00)
+
+#define EEPROM_CH_11_12_TSSI_DELTA	0x002e
+#define EEPROM_CH_11_TSSI_DELTA		FIELD16(0x000f)
+#define EEPROM_CH_12_TSSI_DELTA		FIELD16(0x0f00)
+
+#define EEPROM_CH_13_14_TSSI_DELTA	0x002f
+#define EEPROM_CH_13_TSSI_DELTA		FIELD16(0x000f)
+#define EEPROM_CH_14_TSSI_DELTA		FIELD16(0x0f00)
+
+/*
+ * tssi ratio values (used in get_tssi_ratio)
+ * array idx: [0 ; 24]
+ * delta pwr: [-12;12]
+ */
+const u32 generic_tssi_ratio_values[25] = {0};
+
+/*
+ * tssi ratio deltas (used for delta_power calculation)
+ * 1st idx: 0-CCK, 1-OFDM, 2-HT, 3-HT40, 4-HT+STBC, 5-HT40+STBC
+ * 2nd idx: per mcs delta value
+ */
+const int generic_tssi_ratio_deltas[6][16] = {{0}};
+
+/*
+ * desired tssi for cck, ofdm, ht
+ */
+#define EEPROM_DESTSSI_CCK_MCS0123	0x006f
+#define EEPROM_DESTSSI_CCK_MCS0		FIELD16(0x000f)
+#define EEPROM_DESTSSI_CCK_MCS1		FIELD16(0x00f0)
+#define EEPROM_DESTSSI_CCK_MCS2		FIELD16(0x0f00)
+#define EEPROM_DESTSSI_CCK_MCS3		FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_OFDM_MCS0123	0x0070
+#define EEPROM_DESTSSI_OFDM_MCS0	FIELD16(0x000f)
+#define EEPROM_DESTSSI_OFDM_MCS1	FIELD16(0x00f0)
+#define EEPROM_DESTSSI_OFDM_MCS2	FIELD16(0x0f00)
+#define EEPROM_DESTSSI_OFDM_MCS3	FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_OFDM_MCS4567	0x0071
+#define EEPROM_DESTSSI_OFDM_MCS4	FIELD16(0x000f)
+#define EEPROM_DESTSSI_OFDM_MCS5	FIELD16(0x00f0)
+#define EEPROM_DESTSSI_OFDM_MCS6	FIELD16(0x0f00)
+#define EEPROM_DESTSSI_OFDM_MCS7	FIELD16(0xf000)
+#define EEPROM_DESTSSI_OFDM54		FIELD16(0x0f00)
+
+#define EEPROM_DESTSSI_HT_MCS0123	0x0072
+#define EEPROM_DESTSSI_HT_MCS0		FIELD16(0x000f)
+#define EEPROM_DESTSSI_HT_MCS1		FIELD16(0x00f0)
+#define EEPROM_DESTSSI_HT_MCS2		FIELD16(0x0f00)
+#define EEPROM_DESTSSI_HT_MCS3		FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_HT_MCS4567	0x0073
+#define EEPROM_DESTSSI_HT_MCS4		FIELD16(0x000f)
+#define EEPROM_DESTSSI_HT_MCS5		FIELD16(0x00f0)
+#define EEPROM_DESTSSI_HT_MCS6		FIELD16(0x0f00)
+#define EEPROM_DESTSSI_HT_MCS7		FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_HT_MCS891011	0x0074
+#define EEPROM_DESTSSI_HT_MCS8		FIELD16(0x000f)
+#define EEPROM_DESTSSI_HT_MCS9		FIELD16(0x00f0)
+#define EEPROM_DESTSSI_HT_MCS10		FIELD16(0x0f00)
+#define EEPROM_DESTSSI_HT_MCS11		FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_HT_MCS12131415	0x0073
+#define EEPROM_DESTSSI_HT_MCS12		FIELD16(0x000f)
+#define EEPROM_DESTSSI_HT_MCS13		FIELD16(0x00f0)
+#define EEPROM_DESTSSI_HT_MCS14		FIELD16(0x0f00)
+#define EEPROM_DESTSSI_HT_MCS15		FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_HT_STBC_MCS0123	0x0072
+#define EEPROM_DESTSSI_HT_STBC_MCS0	FIELD16(0x000f)
+#define EEPROM_DESTSSI_HT_STBC_MCS1	FIELD16(0x00f0)
+#define EEPROM_DESTSSI_HT_STBC_MCS2	FIELD16(0x0f00)
+#define EEPROM_DESTSSI_HT_STBC_MCS3	FIELD16(0xf000)
+
+#define EEPROM_DESTSSI_HT_STBC_MCS4567	0x0073
+#define EEPROM_DESTSSI_HT_STBC_MCS4	FIELD16(0x000f)
+#define EEPROM_DESTSSI_HT_STBC_MCS5	FIELD16(0x00f0)
+#define EEPROM_DESTSSI_HT_STBC_MCS6	FIELD16(0x0f00)
+#define EEPROM_DESTSSI_HT_STBC_MCS7	FIELD16(0xf000)
+
+
 /*
  * HW MAC address.
  */
Index: compat-wireless-2013-02-22/drivers/net/wireless/rt2x00/rt2800lib.c
===================================================================
--- compat-wireless-2013-02-22.orig/drivers/net/wireless/rt2x00/rt2800lib.c	2013-08-09 13:05:59.000000000 +0400
+++ compat-wireless-2013-02-22/drivers/net/wireless/rt2x00/rt2800lib.c	2013-08-09 13:07:33.000000000 +0400
@@ -687,8 +687,9 @@
 	struct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;
 	struct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);
 	struct txdone_entry_desc txdesc;
-	u32 word;
+	u32 word, desired_tssi;
 	u16 mcs, real_mcs;
+	u8 rate_mode;
 	int aggr, ampdu;
 
 	/*
@@ -703,6 +704,8 @@
 	real_mcs = rt2x00_get_field32(status, TX_STA_FIFO_MCS);
 	aggr = rt2x00_get_field32(status, TX_STA_FIFO_TX_AGGRE);
 
+	rate_mode = rt2x00_get_field32(word, TXWI_W0_PHYMODE);
+
 	/*
 	 * If a frame was meant to be sent as a single non-aggregated MPDU
 	 * but ended up in an aggregate the used tx rate doesn't correlate
@@ -759,6 +762,32 @@
 		__set_bit(TXDONE_FALLBACK, &txdesc.flags);
 
 	rt2x00lib_txdone(entry, &txdesc);
+
+	switch(rate_mode) {
+	  case RATE_MODE_CCK:
+	    desired_tssi = rt2x00dev->desired_tssi->over_cck[mcs];
+	    break;
+	  case RATE_MODE_OFDM:
+	    desired_tssi = rt2x00dev->desired_tssi->over_ofdm[mcs];
+	    break;
+	  case RATE_MODE_HT_MIX:
+	  case RATE_MODE_HT_GREENFIELD:
+	    if (rt2x00_get_field32(word, TXWI_W0_BW)) { //HT40
+		if(rt2x00_get_field32(word, TXWI_W0_STBC) && (mcs < 7)) {
+	      		desired_tssi = rt2x00dev->desired_tssi->over_ht40_stbc[mcs];
+		} else {
+			desired_tssi = rt2x00dev->desired_tssi->over_ht40[mcs];
+		}
+	    } else {
+		if(rt2x00_get_field32(word, TXWI_W0_STBC) && (mcs < 7)) {
+	      		desired_tssi = rt2x00dev->desired_tssi->over_ht_stbc[mcs];
+		} else {
+			desired_tssi = rt2x00dev->desired_tssi->over_ht[mcs];
+		};
+	    }
+	    break;
+	}
+	rt2x00dev->desired_tssi->current_value = desired_tssi;
 }
 EXPORT_SYMBOL_GPL(rt2800_txdone_entry);
 
@@ -2365,6 +2394,245 @@
 	}
 }
 
+static u32 tssi_ratio(struct rt2x00_dev *rt2x00dev, int delta_power)
+{
+  u32 ratio = 0;
+
+  switch(rt2x00dev->chip.rt) {
+	default:
+		if((delta_power >= -12) && (delta_power <= 12)) {
+			ratio = generic_tssi_ratio_values[delta_power + 12];
+		}
+		break;
+  }
+
+  return ratio;
+}
+
+static void init_desired_tssi_table(struct rt2x00_dev *rt2x00dev, int channel)
+{
+  u16 eeprom;
+  u8 tssi_base, tssi_ch_delta[15], tssi_current_ch_delta;
+  u8 tx_power[28], tx_power_stbc[7], tx_power_ofdm54;
+  const int (*tssi_ratio_deltas)[6][16];
+  int i;
+
+  switch(rt2x00dev->chip.rt) {
+	default:
+		tssi_ratio_deltas = &generic_tssi_ratio_deltas;
+		rt2x00dev->tssi_max = 0;
+		break;
+  }
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_OVER_OFDM54, &eeprom);
+  tssi_base = rt2x00_get_field16(eeprom, EEPROM_TSSI_BASE);
+  rt2x00dev->tssi_ref = tssi_base;
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_TSSI_OVER_OFDM54, &eeprom);
+  tssi_ch_delta[0] = 14; //just to be safe
+  tssi_ch_delta[1] = rt2x00_get_field16(eeprom, EEPROM_CH_1_TSSI_DELTA);
+  tssi_ch_delta[2] = rt2x00_get_field16(eeprom, EEPROM_CH_2_TSSI_DELTA);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_CH_3_4_TSSI_DELTA, &eeprom);
+  tssi_ch_delta[3] = rt2x00_get_field16(eeprom, EEPROM_CH_3_TSSI_DELTA);
+  tssi_ch_delta[4] = rt2x00_get_field16(eeprom, EEPROM_CH_4_TSSI_DELTA);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_CH_5_6_TSSI_DELTA, &eeprom);
+  tssi_ch_delta[5] = rt2x00_get_field16(eeprom, EEPROM_CH_5_TSSI_DELTA);
+  tssi_ch_delta[6] = rt2x00_get_field16(eeprom, EEPROM_CH_6_TSSI_DELTA);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_CH_7_8_TSSI_DELTA, &eeprom);
+  tssi_ch_delta[7] = rt2x00_get_field16(eeprom, EEPROM_CH_7_TSSI_DELTA);
+  tssi_ch_delta[8] = rt2x00_get_field16(eeprom, EEPROM_CH_8_TSSI_DELTA);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_CH_9_10_TSSI_DELTA, &eeprom);
+  tssi_ch_delta[9] = rt2x00_get_field16(eeprom, EEPROM_CH_9_TSSI_DELTA);
+  tssi_ch_delta[10] = rt2x00_get_field16(eeprom, EEPROM_CH_10_TSSI_DELTA);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_CH_11_12_TSSI_DELTA, &eeprom);
+  tssi_ch_delta[11] = rt2x00_get_field16(eeprom, EEPROM_CH_11_TSSI_DELTA);
+  tssi_ch_delta[12] = rt2x00_get_field16(eeprom, EEPROM_CH_12_TSSI_DELTA);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_CH_13_14_TSSI_DELTA, &eeprom);
+  tssi_ch_delta[13] = rt2x00_get_field16(eeprom, EEPROM_CH_13_TSSI_DELTA);
+  tssi_ch_delta[14] = rt2x00_get_field16(eeprom, EEPROM_CH_14_TSSI_DELTA);
+
+  tssi_current_ch_delta = tssi_ch_delta[channel];
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_OFDM_MCS4567, &eeprom);
+  tx_power_ofdm54 = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM54);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_CCK_MCS0123, &eeprom);
+  tx_power[0] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_CCK_MCS0);
+  tx_power[1] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_CCK_MCS1);
+  tx_power[2] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_CCK_MCS2);
+  tx_power[3] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_CCK_MCS3);
+
+  // Boundary verification: the desired TSSI value (CCK: MCS0~MCS3)
+  for (i=0;i<3;i++)
+  {
+    rt2x00dev->desired_tssi->over_cck[i] = tssi_base *
+	tssi_ratio(rt2x00dev, tx_power[i] - tx_power_ofdm54 + tssi_current_ch_delta + (*tssi_ratio_deltas)[0][i]);
+    if (rt2x00dev->desired_tssi->over_cck[i] > (rt2x00dev->tssi_max * 10000))
+    {
+      rt2x00dev->desired_tssi->over_cck[i] = (rt2x00dev->tssi_max * 10000);
+    }
+  }
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_OFDM_MCS0123, &eeprom);
+  tx_power[4] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS0);
+  tx_power[5] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS1);
+  tx_power[6] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS2);
+  tx_power[7] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS3);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_OFDM_MCS0123, &eeprom);
+  tx_power[8] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS4);
+  tx_power[9] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS5);
+  tx_power[10] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS6);
+  tx_power[11] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_OFDM_MCS7);
+
+  // Boundary verification: the desired TSSI value (OFDM: MCS0~MCS7)
+  for (i=0;i<7;i++)
+  {
+    rt2x00dev->desired_tssi->over_ofdm[i] = tssi_base *
+	tssi_ratio(rt2x00dev, tx_power[i + 4] - tx_power_ofdm54 + tssi_current_ch_delta + (*tssi_ratio_deltas)[1][i]);
+    if (rt2x00dev->desired_tssi->over_ofdm[i] > (rt2x00dev->tssi_max * 10000))
+    {
+      rt2x00dev->desired_tssi->over_ofdm[i] = (rt2x00dev->tssi_max * 10000);
+    }
+  }
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_HT_MCS0123, &eeprom);
+  tx_power[12] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS0);
+  tx_power[13] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS1);
+  tx_power[14] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS2);
+  tx_power[15] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS3);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_CCK_MCS0123, &eeprom);
+  tx_power[16] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS4);
+  tx_power[17] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS5);
+  tx_power[18] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS6);
+  tx_power[19] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS7);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_HT_MCS0123, &eeprom);
+  tx_power[20] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS0);
+  tx_power[21] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS1);
+  tx_power[22] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS2);
+  tx_power[23] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS3);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_CCK_MCS0123, &eeprom);
+  tx_power[24] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS4);
+  tx_power[25] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS5);
+  tx_power[26] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS6);
+  tx_power[27] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_MCS7);
+
+  // Boundary verification: the desired TSSI value (HT, HT40: MCS0~MCS15)
+  for (i=0;i<15;i++)
+  {
+    rt2x00dev->desired_tssi->over_ht[i] = tssi_base *
+	tssi_ratio(rt2x00dev, tx_power[i + 12] - tx_power_ofdm54 + tssi_current_ch_delta + (*tssi_ratio_deltas)[2][i]);
+    rt2x00dev->desired_tssi->over_ht40[i] = tssi_base *
+	tssi_ratio(rt2x00dev, tx_power[i + 12] - tx_power_ofdm54 + tssi_current_ch_delta + (*tssi_ratio_deltas)[3][i]);
+    if (rt2x00dev->desired_tssi->over_ht[i] > (rt2x00dev->tssi_max * 10000))
+    {
+      rt2x00dev->desired_tssi->over_ht[i] = (rt2x00dev->tssi_max * 10000);
+    }
+    if (rt2x00dev->desired_tssi->over_ht40[i] > (rt2x00dev->tssi_max * 10000))
+    {
+      rt2x00dev->desired_tssi->over_ht40[i] = (rt2x00dev->tssi_max * 10000);
+    }
+  }
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_HT_STBC_MCS0123, &eeprom);
+  tx_power_stbc[0] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS0);
+  tx_power_stbc[1] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS1);
+  tx_power_stbc[2] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS2);
+  tx_power_stbc[3] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS3);
+
+  rt2x00_eeprom_read(rt2x00dev, EEPROM_DESTSSI_HT_STBC_MCS0123, &eeprom);
+  tx_power_stbc[4] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS4);
+  tx_power_stbc[5] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS5);
+  tx_power_stbc[6] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS6);
+  tx_power_stbc[7] = rt2x00_get_field16(eeprom, EEPROM_DESTSSI_HT_STBC_MCS7);
+
+  // Boundary verification: the desired TSSI value (HT,HT40+STBC: MCS0~MCS7)
+  for (i=0;i<7;i++)
+  {
+    rt2x00dev->desired_tssi->over_ht_stbc[i] = tssi_base *
+	tssi_ratio(rt2x00dev, tx_power_stbc[i] - tx_power_ofdm54 + tssi_current_ch_delta + (*tssi_ratio_deltas)[4][i]);
+    rt2x00dev->desired_tssi->over_ht40_stbc[i] = tssi_base *
+	tssi_ratio(rt2x00dev, tx_power_stbc[i] - tx_power_ofdm54 + tssi_current_ch_delta + (*tssi_ratio_deltas)[5][i]);
+    if (rt2x00dev->desired_tssi->over_ht_stbc[i] > (rt2x00dev->tssi_max * 10000))
+    {
+      rt2x00dev->desired_tssi->over_ht_stbc[i] = (rt2x00dev->tssi_max * 10000);
+    }
+    if (rt2x00dev->desired_tssi->over_ht40_stbc[i] > (rt2x00dev->tssi_max * 10000))
+    {
+      rt2x00dev->desired_tssi->over_ht40_stbc[i] = (rt2x00dev->tssi_max * 10000);
+    }
+  }
+
+  if (rt2x00dev->alt_temp_comp_delta == '\0')
+	rt2x00dev->alt_temp_comp_delta = 0;
+}
+
+static int alt_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
+{
+  u32 desired_tssi, current_tssi;
+  u8 bbp49, bbp47;
+  int i;
+
+  //clear TSSI_UPDATE_REQ first
+  rt2800_bbp_read(rt2x00dev, 47, &bbp47);
+  rt2x00_set_field8(&bbp47, BBP47_TSSI_UPDATE_REQ, 0);
+  rt2800_bbp_write(rt2x00dev, 47, bbp47);
+
+  //write 1 to enable TSSI_INFO update
+  rt2800_bbp_read(rt2x00dev, 47, &bbp47);
+  rt2x00_set_field8(&bbp47, BBP47_TSSI_UPDATE_REQ, 1);
+  rt2800_bbp_write(rt2x00dev, 47, bbp47);
+  mdelay(100);
+
+  //wait for update
+  for(i=0;i<100;i++) {
+	rt2800_bbp_read(rt2x00dev, 47, &bbp47);
+	rt2800_bbp_read(rt2x00dev, 49, &bbp49);	
+	if (!rt2x00_get_field8(bbp47, BBP47_TSSI_UPDATE_REQ) ||
+	     rt2x00_get_field8(bbp49, BBP49_UPDATE_FLAG)) { //TSSI updated, request cleared, update flag set
+		rt2800_bbp_read(rt2x00dev, 47, &bbp47);
+		rt2x00_set_field8(&bbp49, BBP47_TSSI_REPORT_SEL, 0);
+		rt2800_bbp_write(rt2x00dev, 47, bbp47);
+		rt2800_bbp_read(rt2x00dev, 49, &bbp49);
+
+		if(bbp47 > rt2x00dev->tssi_max) {
+			current_tssi = 0;
+		}
+}
+	mdelay(1);
+ }
+
+  desired_tssi = rt2x00dev->desired_tssi->current_value;
+  switch (rt2x00dev->chip.rt) {
+	default:
+		current_tssi = bbp49 * 10000;
+		break;
+  }
+
+  if ((desired_tssi-desired_tssi/32 > current_tssi) &&
+      (rt2x00dev->alt_temp_comp_delta <= 12))
+ {
+    rt2x00dev->alt_temp_comp_delta++;
+  }
+
+  if ((desired_tssi+desired_tssi/32 < current_tssi) &&
+      (rt2x00dev->alt_temp_comp_delta >= -30))
+  {
+    rt2x00dev->alt_temp_comp_delta--;
+  }
+
+    return rt2x00dev->alt_temp_comp_delta;
+}
+
 static int rt2800_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
 {
 	u8 tssi_bounds[9];
@@ -2895,6 +3163,8 @@
 	/* Always recalculate LNA gain before changing configuration */
 	rt2800_config_lna_gain(rt2x00dev, libconf);
 
+	init_desired_tssi_table(rt2x00dev, libconf->rf.channel);
+
 	if (flags & IEEE80211_CONF_CHANGE_CHANNEL) {
 		rt2800_config_channel(rt2x00dev, libconf->conf,
 				      &libconf->rf, &libconf->channel);
Index: compat-wireless-2013-02-22/drivers/net/wireless/rt2x00/rt2x00.h
===================================================================
--- compat-wireless-2013-02-22.orig/drivers/net/wireless/rt2x00/rt2x00.h	2013-08-09 13:05:59.000000000 +0400
+++ compat-wireless-2013-02-22/drivers/net/wireless/rt2x00/rt2x00.h	2013-08-09 13:07:33.000000000 +0400
@@ -750,6 +750,19 @@
 	NUM_IF_COMB,
 };
 
+struct rt2x00_desired_tssi_info {
+	/* desired tssi values */
+	u32 over_cck[4];
+	u32 over_ofdm[8];
+	u32 over_ht_stbc[8];
+	u32 over_ht40_stbc[8];
+	u32 over_ht[16];
+	u32 over_ht40[16];
+
+	/* current desired tssi value */
+	u32 current_value;
+};
+
 /*
  * rt2x00 device structure.
  */
@@ -1029,6 +1042,14 @@
 	 */
 	struct list_head bar_list;
 	spinlock_t bar_list_lock;
+
+	struct rt2x00_desired_tssi_info *desired_tssi;
+
+	int alt_temp_comp_delta;
+
+	u16 tssi_ref;
+
+	u8 tssi_max;
 };
 
 struct rt2x00_bar_list_entry {
